所谓的信号与槽，其实都是函数。**当特定事件被触发时将发送一个信号，而与该信号建立的连接槽，则可以接收到该信号并做出反应。**

要正确处理信号槽，必须借助一个成为moc（meta object compiler)的工具，他是一个C++预处理程序，为高层次的事件处理自动生成所需要的附加代码。它对C++文件中的类声明进行分析并产生用于初始化元对象的C++代码，元对象包含全部信号和槽的名字以及指向这些名字的指针。
**moc读C++源文件，如果发现有Q_OBJECT宏声明的类，它就会生成另外一个C++源文件，包含有该类的元对象代码**。元对象代码是信号槽机制所必须的，用moc产生的C++源文件必须与类实现一起进行编译和链接。

Qt的信号槽机制其实就是按名称查表，这个表就是元数据表
**元对象包含的元信息：信号表、槽表、类信息表、属性表、指向父元对象的指针**。

connect时，元对象检查发送信号的类中是否有这个信号，方法是检查信号表是否有这个名字；同理槽函数，都有则connect正确。
在发送signal的对象中，每一个信号槽的连接，都会创建一个连接对象，并把这个对象保存到**connectionList**这个vector中去。
在响应signal的对象中，也都会创建一个sender对象，并把这个对象附加到sender这个列表中。

**发送信号时，从connectionList中取出对应的连接对象，这个对象保存了这个信号相链接的槽的信息，然后根据信息去调用相应的槽函数**。

**emit信号后都会被转成相应的成员函数，里面调用QMetaObject::activate()函数，从connectList中取出这个信号连接的slot的信息，根据slot的信息调用接收信号的类中的qt_metacall函数，根据slot的索引index调用slot函数。
**

---
**信号槽机制的特点**：

- **类型安全**：只有参数匹配的信号与槽才可以连接成功（信号的参数可以更多，槽会忽略多余的参数）
- **线程安全**：通过借助Qt自己的事件机制，信号槽支持跨线程并保证线程安全
- **松耦合**：信号不关心有哪些或者多少个对象与之连接；槽不关心自己连接了哪些对象的哪些信号。这些都不会影响何时发出信号或信号如何处理
- 信号与槽是**多对多**的关系：一个信号可以连接多个槽，一个槽也可以用来接收多个信号。

---
信号槽连接：

1. QueueConnection:向receiver所在的线程的消息循环发送事件
2. BlockingQueuedConnection:与QueueConnection一样，但是发送信号的线程会等待信号处理结束再继续
3. DirectConnection:在当前线程直接调用receiver的slot，无法支持跨线程的通信
4. AutoConnection:**当前线程与receiver**线程相同时，直接调用slot，否则同- QueuedConnection类型。


---
- Qt信号槽机制精简了程序员的代码量
- 多对多
- 建立与解除绑定十分自由
- 与回调函数的比较
- 参数限定：不能携带模板类参数、不能出现宏定义