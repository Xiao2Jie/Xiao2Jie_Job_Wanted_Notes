智能指针背后的设计思想，将基本类型指针封装为类对象指针，并在析构函数里编写delete语句删除指针指向的内存空间。

- 智能指针自动分配对象并当在不需要对象时自动销毁
- 在拷贝或赋值对象时，auto_ptr的做法是转让所有权，原- 指针就不拥有对象的所有权了。
- auro_ptr不能被放在标准stl容器中。
- 不能共享所有权，即一个智能指针只能拥有一个对象的所有权。
- 不能指向数组，因为他通过delete而不是delete[]删除对象
- 不能讲普通指针转成智能指针，因为智能指针是explicit的。

---
unique_ptr   
	
	独占指针对象（不要使用赋值运算符），并保证指针所指对象生命周期与其一致。

shared_ptr

	可共享指针对象。指针所指对象在所有的相关联的share_ptr生命周期结束时结束。

weak_ptr

	它不能决定所指对象的生命周期，引用所指对象是，需要lock()成shared_ptr才能使用。

---


###智能指针原理：
>智能指针是一个类，在构造函数中传入一个指针，析构函数中释放传入的指针，智能指针的对象都是栈上的对象，所以当函数或程序结束时自动释放。


###常用的智能指针：

- **auto_ptr**:不支持赋值（=运算符）和复制（拷贝构造函数），但赋值或复制时不会提示出错。因为不能复制，所以不能被放入容器中。

- **unique_ptr**:也不支持赋值和复制，但赋值复制时编译时会出错。可以用move赋值。

- **shared_ptr**:基于引用计数的智能指针，可以随意赋值，知道内存的引用计数为0时释放。
 
- **weak_ptr**:weak_ptr是弱作用，指引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针