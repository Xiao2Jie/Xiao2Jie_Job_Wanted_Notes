上柜的《哈利波特》平装本系列，一共有五卷。假设每一卷单独销售均需8欧元。如果读者一次购买不同的两卷，就可以扣除5%的费用，三卷则更多。假设具体折扣的情况如下：
        本数    2       折扣   5%
        本数    3       折扣  10%
        本数    4       折扣  20%
        本数    5       折扣  25% 
问题：设计出算法，能够计算出读者所购买的一批书的最低价格。
二，问题分析：
       优化问题就用动态规划、贪心算法、分支限界轮番狂轰乱炸！！直到找到最优解！！
 贪心策略
  当书的数目N<5时，直接按照折扣购买
  当书的数目N>5时，情况如下：
依此可以穷举出每一种组合的情况，对于任意一种情况(i,j,k,m,n)进行分析
先找出是所有书中5种不同的书，如果有则按照5本书折扣价购买
其次找出剩余书中所有4种书，如果有则按照4本书的折扣价购买
再找出剩余书中所有3种书，如果有则按照3本书的折扣价购买 
最后在剩余书中找出所有2种书，如果有则按照2本书的折扣价购买
剩下的书则按照全价购买。
       如果按照这种方法（贪心法）存在反例，比如买8本书时，可以拆成5+3，折扣为1.55；也可以拆成4+4，折扣为1.6 这种两种情况组合中都包括，通过选择一个折扣最低的可以排除掉第一种情况。
       结论：贪心策略不可取
动态规划
         要用动态规划解答首先要找到，动态规划的递归公式，因为动态规划是自顶向下层层递归，然后自底向下层层解答！最后根据底层结论求解最后结果。
        五卷书的价格相同都是8欧元，所以购买（1，0，0，0，0）跟（0，1，0，0，0）效果一样。这里就可以简化为，让所购买书按照本书递增（递减），从而方便讨论。
         要处理的参数为购买每种卷的个数，所以递归一定跟这五个参数相关。可以把参数按照从小到大顺序排列。讨论不为0的参数的个数，从而求出所有可能的折扣种类。然后从当前折扣种类中取价格最小值。
        （X1,X2,X3,X4,X5）代表购买每卷的个数，F（X1，X2，X3，X4，X5）代表最低价格。X1 < X2 < X3 < X4 < X5
                            F（X1，X2，X3，X4，X5）=0  ；当所有参数都为0的情况（这也是退出递归的出口）
                             F（X1，X2，X3，X4，X5）= min{
                                                          5*8*(1-25%) +F（X1-1，X2-1，X3-1，X4-1，X5-1） //参数全部  > 0
                                                          4*8*(1-20%) +F（X1，X2-1，X3-1，X4-1，X5-1）    //x2 > 0
                                                          3*8*(1-10%) +F（X1，X2，X3-1，X4-1，X5-1）        //x3 > 0
                                                          2*8*(1-5%) +F（X1，X2，X3，X4-1，X5-1）             //x4 > 0
                                                          8 +F（X1，X2，X3，X4，X5-1）                                  //x5 > 0
                                                          }

#include<iostream>
using namespace std;
template <typename T>
void InsertSort(T m[], int length)   //插入排序, 从小到大
{
	for(int i = 1; i < length; ++i)
	{
		int j ;
		T tmp = m[i];
//m[i]前面的都是排好序的，m[i]如果比前面的小，就把前面的向后挪一个位置，直到找到自己的位置
		for( j = i; j>0 && m[j-1]>tmp; --j)
			m[j] = m[j-1];
		m[j] = tmp;
	}
}
double Min(double a, double b, double c, double d, double e)   //返回最小值
{
	double A[5] = {a, b, c ,d ,e};
	InsertSort(A, 5);
	return A[0];
}
double BuyBook(int a, int b, int c, int d, int e)
{
	//把要买的书的数目按从小到大排序,因为每种书价钱一样,所以一种书放在哪个位置无所谓
	int n[5] = {a, b, c, d, e};
	InsertSort(n, 5);
	a = n[0];
	b = n[1];
	c = n[2];
	d = n[3];
	e = n[4];
	const double large = 100000;  //定义一个很大的值,去最小值时不会取到这个值
	if(n[0]>0)  //数目最少的书都至少有一本,因此此轮可以买1, 2, 3, 4, 5,本都行,去最小值,再递归
	{
		return Min(8.0+BuyBook(a, b, c, d, e-1),
						2*8.0*0.95 + BuyBook(a, b, c, d-1, e-1),
						3*8.0*0.9 + BuyBook(a, b, c-1, d-1, e-1),
						4*8.0*0.80 + BuyBook(a, b-1, c-1, d-1, e-1),
						5*8.0*0.75 + BuyBook(a-1, b-1, c-1, d-1, e-1));
	}
	else if(n[0]==0 && n[1]>0)  //数目最少的一种没了,就不能5种都买了
	{
		return Min(8.0+BuyBook(a, b, c, d, e-1),
			2*8.0*0.95 + BuyBook(a, b, c, d-1, e-1),
			3*8.0*0.9 + BuyBook(a, b, c-1, d-1, e-1),
			4*8.0*0.80 + BuyBook(a, b-1, c-1, d-1, e-1),
			large);
	}
	else if(n[0]==0 && n[1] == 0 && n[2]>0)  //数目最少的2种没了,最多买3种
	{
		return Min(8.0+BuyBook(a, b, c, d, e-1),
			2*8.0*0.95 + BuyBook(a, b, c, d-1, e-1),
			3*8.0*0.9 + BuyBook(a, b, c-1, d-1, e-1),
			large,
			large);
	}
	else if(n[0]==0 && n[1] == 0 && n[2] == 0 && n[3]>0)  //数目最少的3种没了,最多买2种
	{
		return Min(8.0+BuyBook(a, b, c, d, e-1),
			2*8.0*0.95 + BuyBook(a, b, c, d-1, e-1),
			large,
			large,
			large);
	}
	else if(n[0]==0 && n[1] == 0 && n[2] == 0 && n[3] == 0 && n[4]>0)  //数目最少的4种没了,最多买1种
	{
		return 8.0+BuyBook(a, b, c, d, e-1);
	}
	else
	{
		return 0;
	}
}
int main()
{
	int n[5] = {5,9,3,6,4};
	cout<<BuyBook(n[0], n[1], n[2], n[3], n[4])<<endl;
}
最后结果为176


