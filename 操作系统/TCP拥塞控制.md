在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞


 **网络拥塞往往是由许多因素引起的，简单的提高节点处理机的速度或者扩大结点缓存的存储空间并不能解决拥塞问题。**

例如:
当某个结点缓存容量扩展到非常大，于是凡到达该结点的分组均可在结点的缓存队列中排队，不受任何限制。由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数的分组在排队等待时间会大大增加，结果上层软件只好把他们进行重传。


##拥塞控制四种算法：慢开始、拥塞避免、快重传、快速恢复


###慢开始
慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。 当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以 **一次传输轮次之后拥塞窗口就加倍。**




为了防止 cwnd 增长过大引起网络拥塞，还需设置一个 **慢开始门限 ssthresh** 状态变量。 ssthresh 的用法如下：

**当 cwnd<ssthresh 时，使用慢开始算法。**

**当 cwnd>ssthresh 时，改用拥塞避免算法。**

**当 cwnd=ssthresh 时，慢开始与拥塞避免算法任意 。**


###拥塞避免算法
让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是加倍。这样拥塞窗口按线性规律缓慢增长。



  无论是在 慢开始阶段 还是在 拥塞避免阶段 ，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把 慢**开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1 ，执行慢开始算法**

![](http://i.imgur.com/uSQ3i2E.jpg)





###快重传
 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。（为什么会收到重复序号，因为ack_num必须是连续的，当某个ack丢失时，后面的ack_num都会是这个ack_num）.

![](http://i.imgur.com/3CuBCxf.jpg)



  **快恢复算法 有以下两个要点：**
     
- 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 慢开始门限减半 ，这是为了预防网络发生拥塞。

- 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认, 发送方现在 认为网络很可能没有发生拥塞 ，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，是拥塞窗口的线性增大


[http://blog.csdn.net/sicofield/article/details/9708311](http://blog.csdn.net/sicofield/article/details/9708311)
