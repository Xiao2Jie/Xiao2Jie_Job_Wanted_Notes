##临界区 Critical Section ：
**通过对多线程的串行化来访问公共资源或一段代码 。**

保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。

**虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程 ** 



##互斥量（Mutex）

协调共同对一个共享资源的单独访问而设计的

互斥量跟临界区很相似， **只有拥有互斥对象的线程才具有访问资源的权限** ，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。 **因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。** 



##信号量（Semaphores）：

为控制一个具有有限数量用户资源而设计

**信号允许多个线程同时使用共享资源**  ，这与操作系统中的PV操作相同。它指出了同时访问共享 资源的线程 最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。 

P操作 申请资源：

- S减1； 
- 若S减1后仍大于等于零，则进程继续执行； 
- 若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。 

V操作 释放资源： 

- S加1； 
- 若相加结果大于零，则进程继续执行； 
- 若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。



##事件（Event） ：

用来通知线程有一些事件已发生，从而启动后继任务的开始

事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。


#总结： 
1． 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多， **所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量**  。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。 

2 互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和 线程退出。 

3 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理， **比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器**。

---
[来源csdn](http://blog.csdn.net/bao_qibiao/article/details/4516196)