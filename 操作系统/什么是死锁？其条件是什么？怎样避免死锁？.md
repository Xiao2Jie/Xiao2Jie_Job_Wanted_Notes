[toc]
# 死锁的概念
在两个或多个并发的进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在 **保持着资源** ，在未改变这种状态之前都不能 **向前推进** ，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程被无限期阻塞、互相等待的一种状态。

# 产生死锁的主要原因

- 系统资源不足
- 进程运行推进的顺序不合适
- 资源分配不当

#产生死锁的必要条件 ：

- **互斥** ：一个资源每次只能被一个进程使用
- **不可抢占** ：进程已获得的资源，在未使用完之前不可强行剥夺。
- **占有并等待** ：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **环形等待** ：若干进程之间形成一种首尾相接的环形等待资源关系。

#常用避免死锁的方法：

有序资源分配法
银行家算法

#解决死锁问题的策略：

- **互斥条件**： 否定。资源的互斥性是由其自身决定的。

- **不剥夺条件**： 很难实现。系统一般让资源占有者自己释放资源，而不采用抢占的方式。

- **占有并等待**：  在资源分配策略上可以采取静态的一次性分配资源的方法来保证死锁不可能发生，这是一种很保守的静态预防死锁的策略，但是资源利用率低下。

- **环路条件**： 在资源分配前检查是否会出现环路，预测是否可能发生死锁，只要有这种可能就不予分配资源。即采用动态分配资源的方法。

##死锁的避免
**银行家算法** ，该方法允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。从而避免发生死锁。

##死锁的解除：

- 强制性的从系统中撤销一个或多个死锁的进程来断开循环等待链，并收回分配给终止进程的全部资源供剩下的进程使用

- 使用一个有效的挂起和解除机构来挂起一些死锁的进程，其实质是从被挂起的进程那里抢占资源以解除死锁。